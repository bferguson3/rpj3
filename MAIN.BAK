#include <stdio.h>
#include "rpj3\IBK.H"
#include <CONIO.H>
#include <IOSTREAM.H>
#include "rpj3\BENT.H"
//#include <STDLIB.H>
//#include <FSTREAM.H>
//#include <TIME.H>

extern u16 SB_BASE;

#define CRTC_REG 0x3d4 
#define HZTOTAL_REG 0
#define CRTC_DATA 0x3d5
#define PAGE1_OFFSET (u16)(640*200)
#define BLANK_OFFSET (u16)(PAGE1_OFFSET*2)
// RAM
char ibk[3204];
char zp[0x10];
//


void movecursor(int x, int y);
void reset(void);
void cls(void);

u8 imgdata[100];
u8 last_kb_pressed;
unsigned const char ESC = 0x1b;
int fps = 60;
int _wait = 1000 / fps;
int frameskip = 0;

u8 input1;
u8 input1_last;
u8 framecounter = 0;

#define BUTTON_UP 1
#define BUTTON_DOWN 2
#define BUTTON_LEFT 4
#define BUTTON_RIGHT 8
#define BUTTON_A 16
#define BUTTON_B 32

void reset()
{
    //Clears all break codes, sets text to default colors
    cout << ESC << "[0m";
}

void cls()
{
    //Fills entire screen with " " and positions cursor to top left.
    cout << ESC << "[2J";
}

void movecursor(int x, int y)
{
    if(y < 0)
    {
		cout << ESC << "[" << -y << "A";
    }
    else
    {
		cout << ESC << "[" << y << "B";
    }
    if(x < 0)
    {
		cout << ESC << "[" << -x << "D";
    }
    else
    {
		cout << ESC << "[" << x << "C";
    }
	
}

// if we know that a certain key was pressed,
// and we know that either:
// - 1 second has passed
  // or 
// - we got a keyup event for a different direction

int get_keyboard_input(void)
{
	//input1_last = input1;
	//input1 &= 0xf0; // erase movement input
	u8 k = read_key();
	u8 QUITFLAG = 0;
	
	if (k >= 128)
   {
	   unsigned char kk = k - 128;
	   if (kk == KB_UP)
	   {
			//input1 &= ~(0xf);
			input1 &= ~(KB_UP)
	   }
	   else if (kk == KB_DOWN)
	   {
		 	input1 &= ~(KB_DOWN);
	   }
	   else if (kk == KB_RIGHT)
	   {
			input1 &= ~(KB_RIGHT);
	   }
	   else if (kk == KB_LEFT)
	   {
			input1 &= ~(KB_LEFT);
	   }
	   else if (kk == KB_Z)
	   {
		 	input1 &= ~(KB_Z);
	   }
	   else if (kk == KB_X)
	   {
		 	input1 &= ~(KB_X);
	   }
	   
   }
   else

   {
	   	if (k == KB_UP)
	   	{
			//input1 &= ~(0xf);
		 	input1 |= BUTTON_UP;
	    }
	    else if (k == KB_DOWN)
	    {
			//input1 &= ~(0xf);
			input1 |= BUTTON_DOWN;
	    }
	    else if (k == KB_LEFT)
	    {
			//input1 &= ~(0xf);
			input1 |= BUTTON_LEFT;
	    }
	    else if (k == KB_RIGHT)
	    {
			//input1 &= ~(0xf);
			input1 |= BUTTON_RIGHT;
	    }
	    else if (k == KB_Z)
	    {
			
		    input1 |= BUTTON_A;
			//input1 &= ~(BUTTON_B);
	   	}
	   	else if (k == KB_X)
	   	{
			input1 |= BUTTON_B;
			//input1 &= ~(BUTTON_A);
	   	}
	   	else if (k == KB_ESC)
	   	{
		  	QUITFLAG = 1;
       	}
	   
   }

   return k;
}



void main(int argc, char* argv[])
{
	u16 rambase;
	asm mov ax,es
	asm mov [rambase], ax

	// This shouldn't break but we'll see
	SetVGASegment();

	//printVarSizes();
	s16 i;
	u8 st, ste;

	if(argc == 2)
	{
		SB_BASE=0x0;
		for(i = 0; i < sizeof(argv[1]); i++)
		{
			SB_BASE += hex2c(argv[1][i]) * (0x1 << (4*(sizeof(argv[1])-i)));
		}
	}
	if(argc == 1)
		SB_BASE = 0x220;
	//GetChannelType();

	if(ResetDSP() == 0)
		printf("DSP init OK!\n");
	else
	{
		printf("SB DSP init failed. Exiting.\n");
		return;
	}
	PrintDSPVersion();
	// Load OPL general midi instrument bank
	u16 oplsize = file2buf("GMOPL.IBK", ibk);
	printf("Loaded OPL bank of size %d.\n", oplsize);
	FM_AdlibReset();
	for(u8 j = 1; j <= 0xf5; j++)
	{
		FM_RegSelect(j);
		FM_RegWrite(0);
	}

	

	imgdata[0] = 0x0;
	imgdata[1] = 0xff;
	imgdata[2] = 0;
	imgdata[3] = 255;
	u8* imgloc = &imgdata[0];

	SetVideoMode(0xe);
	
	//EGA_WriteByte(320/8, 100, 0xff);
	// Set destination to 320, 100


	// for bitmaps, we need STOSB.
	// stores AL at [ES:DI], inc d
// TEST
	FM_SetInstrument(62);

	FM_RegSelect(0xA0); //ch0 f num low
	FM_RegWrite(0x98);
	FM_RegSelect(0xB0); // ch0 key, f num hi
	FM_RegWrite(0x31);
	// off first
	//if(CLK_TCK < fps){
	//	fps = CLK_TCK;
	//	frameskip = 0;
	//
	fps = 255;
	//clock_t start = clock();
	//clock_t end = 0;

	s16 px,py;
	px = 40;

	/* 
	* Result of actual resolution check:
	* 100 x 191
	*/
	u8 result_h;
	u16 result_v;
	u8 ovfl;
	asm mov dx, CRTC_REG 
	asm mov ax, HZTOTAL_REG 
	asm out dx, al
	asm inc dx 
	asm in al, dx 
	asm mov [result_h], al
	asm mov dx, CRTC_REG 
	asm mov ax, 6 
	asm out dx, al
	asm inc dx 
	asm in al, dx
	asm mov ah,0
	asm mov [result_v], ax
	asm mov dx, CRTC_REG 
	asm mov ax, 7 
	asm out dx, al
	asm inc dx 
	asm in al, dx 
	asm mov [ovfl], al
#define BIT(n) (1 << n)
	if(ovfl & BIT(5)) result_v |= BIT(8);
	if(ovfl & BIT(0)) result_v |= BIT(9);

	while(1)
	{

		WaitRetrace();

		/*
		* !!!!!!! MAIN !!!!!!!
		*/
		framecounter++;
		if(framecounter > 59) framecounter = 0;
		
		int ink = get_keyboard_input();
		printf("%c[%dD%c[%dA", 0x1b, 80, 0x1b, 25);
		movecursor(10, 10);
		cout << flush;
		printf("Hscan: %d\n", result_h);
		printf("Vscan: %d\n", result_v);

		if(ink == 1)
			goto _globalquit;
		printf("Input: ");
		for(s8 i = 7; i >= 0; i--)
		{
			if(input1 & (1 << i)) printf("1");
			else printf("0");
		}
		printf("\nFPS: %d",fps);
		u16 pos = (80*100) + px;
		
		
		// wait until bit 3 is 0
		/* 
		* !!!!!!! DRAW !!!!!
		*/
		WaitVBlank();

		SetVGASegment();
		SetVGABitmask(0xff);  //REset all bits
		SetVGAPlaneMask(0xf); // of all colors
		
		asm mov di, [pos]
		asm mov cx, 8  // 8 loops
		asm mov si, 80 // +1 Y pixel = +80 bytes
		_meloop:
		asm {
			mov ah,[es:di]
			mov al,0h
			mov [es:di],al
			add di,si
			loop _meloop
		} // 170 = 0b10101010
		if((input1 & BUTTON_RIGHT))
		{
			px++;
			fps++;
		}
		if((input1 & BUTTON_LEFT))
		{
			px--;
		}
		
		if(px > 79) px = 79;
		if(px < 0) px = 0;
		SetVGASegment();
		SetVGABitmask(0xff); // SET bits of
		SetVGAPlaneMask(LIGHTMAGENTA); // magenta planes
		
		pos = (80*100) + px;
		asm mov di, [pos]
		asm mov cx, 8  // 8 loops
		asm mov si, 80 // +1 Y pixel = +80 bytes
		_meloop2:
		asm {
			mov ah,[es:di]
			mov al,170
			mov [es:di],al
			add di,si
			loop _meloop2
		} // 170 = 0b10101010
		
		//start = clock();
		
	}
_globalquit:
	FM_RegSelect(0xb0);
	FM_RegWrite(0xc0);
	asm mov es,[rambase]
	SetVideoMode(3);
	//fclose(stdin);
}
/*
   Channel        1   2   3   4   5   6   7   8   9
   Operator 1    00  01  02  08  09  0A  10  11  12
   Operator 2    03  04  05  0B  0C  0D  13  14  15
*/

// enable color bitplanes
	
	// Set memory pointer to vram base, set di (destination index) to page 0 (0000h)
	// write mode 1 - not sure what this does
	/*
	asm {
		mov dx,0x3ce
		mov al,5
		out dx,al
		inc dx 
		nop
		nop 
		nop 
		nop 
		in al,dx 
		and al,not 3
		or al,1 
		nop 
		nop 
		nop 
		nop 
		out dx,al 
	}
	*/ 